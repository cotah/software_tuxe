generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  STAFF
  KITCHEN
}

enum BusinessType {
  RESTAURANT
  BIKE_SHOP
  CLINIC
  PET_STORE
  GENERAL
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PREPARING
  READY
  DELIVERED
  COMPLETED
  CANCELLED
  IN_PROGRESS
  READY_FOR_PICKUP
  QUOTE_REQUESTED
  QUOTE_SENT
  QUOTE_APPROVED
  QUOTE_REJECTED
  IN_PREPARATION
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  PIX
  TRANSFER
  OTHER
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum CalendarProvider {
  GOOGLE
  MICROSOFT
  CALENDLY
}

enum SyncState {
  OK
  NEEDS_UPDATE
  CONFLICT
  ERROR
}

enum LeadStatus {
  NEW
  ENGAGED
  QUALIFIED
  WAITING_HUMAN
  CONVERTED
  LOST
}

enum LeadTemperature {
  HOT
  WARM
  COLD
}

enum LeadSource {
  INSTAGRAM
  FACEBOOK
  WHATSAPP
  WEBSITE
  OTHER
}

enum IdentityProvider {
  MANYCHAT
  INSTAGRAM
  FACEBOOK
  WHATSAPP
  WEBSITE
}

enum Channel {
  INSTAGRAM
  FACEBOOK
  WHATSAPP
  WEBSITE
  EMAIL
  OTHER
}

enum ConversationState {
  OPEN
  BOT_ACTIVE
  HUMAN_REQUIRED
  CLOSED
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageProvider {
  MANYCHAT
  SYSTEM
  HUMAN
}

enum WebhookDeliveryStatus {
  PENDING
  SENT
  FAILED
}

enum AIUsageType {
  LEAD_CLASSIFICATION
  CONVERSATION_SUMMARY
  DRAFT_REPLY
}

enum NotificationChannel {
  EMAIL
  WHATSAPP
  SMS
  PUSH
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  SKIPPED
}

enum IntegrationType {
  BITRIX24
  IFOOD
  RAPPI
  BLING
  TINY_ERP
  GENERIC
}

model Company {
  id             String           @id @default(uuid())
  name           String
  businessType   BusinessType     @default(GENERAL)
  email          String?
  phone          String?
  logo           String?
  address        String?
  locale         String           @default("pt-BR")
  currency       String           @default("BRL")
  timezone       String           @default("America/Sao_Paulo")
  workingHours   Json?
  settings       Json?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  users          User[]
  services       Service[]
  products       Product[]
  inventoryItems InventoryItem[]
  orders         Order[]
  payments       Payment[]
  schedules      Schedule[]
  rosters        Roster[]
  checkIns       CheckIn[]
  workflows      Workflow[]
  integrations   Integration[]
  notifications  Notification[]
  translations   Translation[]
  appointments   Appointment[]
  appointmentStatusHistory AppointmentStatusHistory[]
  calendarConnections CalendarProviderConnection[]
  appointmentExternalMappings AppointmentExternalMapping[]
  calendarSettings TenantCalendarSettings?
  leads          Lead[]
  leadIdentities LeadIdentity[]
  conversations  Conversation[]
  messages       Message[]
  leadStatusHistory LeadStatusHistory[]
  webhookEndpoints WebhookEndpoint[]
  webhookDeliveries WebhookDelivery[]
  aiSettings     TenantAISettings?
  aiUsageLogs    AIUsageLog[]
}

model User {
  id           String        @id @default(uuid())
  email        String        @unique
  password     String
  name         String
  role         UserRole
  phone        String?
  avatar       String?
  isActive     Boolean       @default(true)
  lastLoginAt  DateTime?
  companyId    String
  company      Company       @relation(fields: [companyId], references: [id])
  refreshTokens RefreshToken[]
  orders       Order[]       @relation("OrderAssignee")
  rosters      Roster[]
  checkIns     CheckIn[]
  appointmentsAssigned Appointment[] @relation("AppointmentAssignee")
  appointmentsCreated  Appointment[] @relation("AppointmentCreatedBy")
  appointmentStatusChanges AppointmentStatusHistory[] @relation("AppointmentStatusChangedBy")
  leadStatusChanges LeadStatusHistory[] @relation("LeadStatusChangedBy")
  assignedConversations Conversation[] @relation("ConversationAssignee")
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  revoked   Boolean  @default(false)
  revokedAt DateTime?
  createdAt DateTime @default(now())
}

model Service {
  id          String      @id @default(uuid())
  companyId   String
  company     Company     @relation(fields: [companyId], references: [id])
  name        String
  description String?
  duration    Int?
  price       Decimal     @db.Decimal(10, 2)
  isActive    Boolean     @default(true)
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Product {
  id          String          @id @default(uuid())
  companyId   String
  company     Company         @relation(fields: [companyId], references: [id])
  name        String
  sku         String?
  description String?
  inventory   InventoryItem[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([companyId, sku])
}

model InventoryItem {
  id         String   @id @default(uuid())
  productId  String
  product    Product  @relation(fields: [productId], references: [id])
  companyId  String
  company    Company  @relation(fields: [companyId], references: [id])
  quantity   Int      @default(0)
  minStock   Int?
  unit       String   @default("unit")
  location   String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([productId, companyId], name: "productId_companyId")
}

model Order {
  id            String              @id @default(uuid())
  orderNumber   String              @unique
  status        OrderStatus
  totalAmount   Decimal             @db.Decimal(10, 2)
  companyId     String
  company       Company             @relation(fields: [companyId], references: [id])
  customerName  String?
  customerPhone String?
  customerEmail String?
  notes         String?
  assignedTo    String?
  assignee      User?               @relation("OrderAssignee", fields: [assignedTo], references: [id])
  workflowId    String?
  workflow      Workflow?           @relation(fields: [workflowId], references: [id])
  completedAt   DateTime?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  items         OrderItem[]
  payments      Payment[]
  statusHistory OrderStatusHistory[]
}

model OrderItem {
  id        String   @id @default(uuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  serviceId String
  service   Service  @relation(fields: [serviceId], references: [id])
  quantity  Int
  price     Decimal  @db.Decimal(10, 2)
  notes     String?
}

model OrderStatusHistory {
  id            String   @id @default(uuid())
  orderId       String
  order         Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  status        String
  previousStatus String?
  changedBy     String?
  notes         String?
  createdAt     DateTime @default(now())
}

model Payment {
  id            String         @id @default(uuid())
  orderId       String
  order         Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  companyId     String
  company       Company        @relation(fields: [companyId], references: [id])
  amount        Decimal        @db.Decimal(10, 2)
  method        PaymentMethod
  status        PaymentStatus  @default(PENDING)
  transactionId String?
  metadata      Json?
  paidAt        DateTime?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Schedule {
  id            String   @id @default(uuid())
  companyId     String
  company       Company  @relation(fields: [companyId], references: [id])
  title         String
  description   String?
  startDate     DateTime
  endDate       DateTime
  type          String
  customerName  String?
  customerPhone String?
  customerEmail String?
  status        String   @default("scheduled")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Roster {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  date      DateTime
  startTime String
  endTime   String
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CheckIn {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  checkIn   DateTime @default(now())
  checkOut  DateTime?
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Workflow {
  id            String      @id @default(uuid())
  name          String
  businessType  BusinessType
  entityType    String
  statuses      Json
  defaultStatus String
  isSystem      Boolean     @default(false)
  companyId     String?
  company       Company?    @relation(fields: [companyId], references: [id])
  orders        Order[]
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model Integration {
  id           String            @id @default(uuid())
  companyId    String
  company      Company           @relation(fields: [companyId], references: [id])
  type         IntegrationType
  name         String
  config       Json
  webhookUrl   String?
  isActive     Boolean           @default(true)
  lastSyncAt   DateTime?
  syncStatus   String?
  errorMessage String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  syncLogs     IntegrationSyncLog[]
}

model IntegrationSyncLog {
  id            String   @id @default(uuid())
  integrationId String
  integration   Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  action        String
  status        String
  entityType    String?
  entityId      String?
  requestData   Json?
  responseData  Json?
  errorMessage  String?
  duration      Int?
  createdAt     DateTime @default(now())
}

model Notification {
  id            String             @id @default(uuid())
  companyId     String
  company       Company            @relation(fields: [companyId], references: [id])
  channel       NotificationChannel
  recipient     String
  subject       String?
  message       String
  template      String?
  templateData  Json?
  metadata      Json?
  status        NotificationStatus @default(PENDING)
  retryCount    Int                @default(0)
  maxRetries    Int                @default(3)
  errorMessage  String?
  sentAt        DateTime?
  failedAt      DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
}

model Translation {
  id        String   @id @default(uuid())
  key       String
  locale    String
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id])
  namespace String?
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([key, locale, companyId], name: "key_locale_companyId")
}

model Appointment {
  id               String                        @id @default(cuid())
  tenantId         String
  tenant           Company                       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  title            String
  description      String?
  status           AppointmentStatus             @default(SCHEDULED)
  startAt          DateTime
  endAt            DateTime
  timezone         String
  customerId       String?
  assignedUserId   String?
  assignedUser     User?                         @relation("AppointmentAssignee", fields: [assignedUserId], references: [id])
  location         String?
  metadata         Json?
  createdByUserId  String
  createdBy        User                          @relation("AppointmentCreatedBy", fields: [createdByUserId], references: [id])
  statusHistory    AppointmentStatusHistory[]
  externalMappings AppointmentExternalMapping[]
  createdAt        DateTime                      @default(now())
  updatedAt        DateTime                      @updatedAt

  @@index([tenantId, startAt])
  @@index([tenantId, assignedUserId])
}

model AppointmentStatusHistory {
  id              String             @id @default(cuid())
  tenantId        String
  tenant          Company            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointmentId   String
  appointment     Appointment        @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  fromStatus      AppointmentStatus?
  toStatus        AppointmentStatus
  changedByUserId String?
  changedBy       User?              @relation("AppointmentStatusChangedBy", fields: [changedByUserId], references: [id])
  reason          String?
  createdAt       DateTime           @default(now())

  @@index([tenantId, appointmentId])
}

model CalendarProviderConnection {
  id                    String                      @id @default(cuid())
  tenantId              String
  tenant                Company                     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  provider              CalendarProvider
  displayName           String?
  isEnabled             Boolean                     @default(true)
  scopes                String[]
  accessTokenEncrypted  String?
  refreshTokenEncrypted String?
  expiresAt             DateTime?
  externalAccountId     String?
  externalAccountEmail  String?
  webhookChannelId      String?
  webhookResourceId     String?
  webhookExpiration     DateTime?
  clientState           String?
  createdAt             DateTime                    @default(now())
  updatedAt             DateTime                    @updatedAt
  mappings              AppointmentExternalMapping[]

  @@unique([tenantId, provider])
}

model AppointmentExternalMapping {
  id                 String                @id @default(cuid())
  tenantId           String
  tenant             Company               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  appointmentId      String
  appointment        Appointment           @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  provider           CalendarProvider
  externalCalendarId String
  externalEventId    String
  etag               String?
  lastSyncedAt       DateTime?
  syncState          SyncState             @default(OK)
  errorMessage       String?
  connectionId       String?
  connection         CalendarProviderConnection? @relation(fields: [connectionId], references: [id])
  createdAt          DateTime              @default(now())
  updatedAt          DateTime              @updatedAt

  @@unique([tenantId, provider, externalCalendarId, externalEventId])
  @@unique([tenantId, provider, appointmentId])
}

model TenantCalendarSettings {
  tenantId                String            @id
  tenant                  Company           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  preventOverbooking      Boolean           @default(false)
  defaultTimezone         String            @default("Europe/Dublin")
  defaultCalendarProvider CalendarProvider?
  defaultExternalCalendarId String?
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
}

model Lead {
  id                String             @id @default(cuid())
  tenantId          String
  tenant            Company            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  fullName          String?
  email             String?
  phone             String?
  locale            String?
  status            LeadStatus         @default(NEW)
  temperature       LeadTemperature?
  source            LeadSource         @default(OTHER)
  tags              String[]
  metadata          Json?
  lastInteractionAt DateTime?
  aiIntent          String?
  aiConfidence      Float?
  aiTemperature     LeadTemperature?
  aiLastClassifiedAt DateTime?
  aiNotes           Json?
  identities        LeadIdentity[]
  conversations     Conversation[]
  statusHistory     LeadStatusHistory[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@unique([tenantId, email])
  @@unique([tenantId, phone])
  @@index([tenantId, status])
  @@index([tenantId, source])
}

model LeadIdentity {
  id               String           @id @default(cuid())
  tenantId         String
  tenant           Company          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leadId           String
  lead             Lead             @relation(fields: [leadId], references: [id], onDelete: Cascade)
  provider         IdentityProvider
  externalUserId   String
  externalThreadId String?
  createdAt        DateTime         @default(now())

  @@unique([tenantId, provider, externalUserId])
  @@index([tenantId, leadId])
}

model Conversation {
  id             String             @id @default(cuid())
  tenantId       String
  tenant         Company            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leadId         String
  lead           Lead               @relation(fields: [leadId], references: [id], onDelete: Cascade)
  channel        Channel
  state          ConversationState  @default(OPEN)
  assignedUserId String?
  assignedUser   User?              @relation("ConversationAssignee", fields: [assignedUserId], references: [id])
  lastMessageAt  DateTime?
  messages       Message[]
  aiSummary      String?
  aiSuggestedNextActions String?
  aiLastSummarizedAt DateTime?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  @@index([tenantId, leadId])
  @@index([tenantId, state])
}

model Message {
  id             String            @id @default(cuid())
  tenantId       String
  tenant         Company           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  direction      MessageDirection
  text           String?
  rawPayload     Json?
  provider       MessageProvider
  createdAt      DateTime          @default(now())

  @@index([tenantId, conversationId])
}

model LeadStatusHistory {
  id              String       @id @default(cuid())
  tenantId        String
  tenant          Company      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leadId          String
  lead            Lead         @relation(fields: [leadId], references: [id], onDelete: Cascade)
  fromStatus      LeadStatus?
  toStatus        LeadStatus
  changedByUserId String?
  changedBy       User?        @relation("LeadStatusChangedBy", fields: [changedByUserId], references: [id])
  reason          String?
  createdAt       DateTime     @default(now())

  @@index([tenantId, leadId])
}

model WebhookEndpoint {
  id              String    @id @default(cuid())
  tenantId        String
  tenant          Company   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name            String
  url             String
  secretEncrypted String
  isEnabled       Boolean   @default(true)
  eventTypes      String[]
  deliveries      WebhookDelivery[]
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([tenantId, isEnabled])
}

model WebhookDelivery {
  id         String                @id @default(cuid())
  tenantId   String
  tenant     Company               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  endpointId String
  endpoint   WebhookEndpoint       @relation(fields: [endpointId], references: [id], onDelete: Cascade)
  eventType  String
  payload    Json
  status     WebhookDeliveryStatus @default(PENDING)
  attempts   Int                   @default(0)
  lastError  String?
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt

  @@index([tenantId, endpointId])
  @@index([tenantId, status])
}

model TenantAISettings {
  tenantId          String   @id
  tenant            Company  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  enabled           Boolean  @default(false)
  dailyTokenLimit   Int      @default(0)
  defaultModel      String   @default("gpt-4.1-mini")
  allowSummarize    Boolean  @default(true)
  allowDraftReply   Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model AIUsageLog {
  id               String       @id @default(cuid())
  tenantId         String
  tenant           Company      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId           String?
  leadId           String?
  conversationId   String?
  usageType        AIUsageType
  model            String
  promptTokens     Int          @default(0)
  completionTokens Int          @default(0)
  totalTokens      Int          @default(0)
  cost             Float        @default(0)
  success          Boolean
  errorMessage     String?
  createdAt        DateTime     @default(now())

  @@index([tenantId, createdAt])
  @@index([tenantId, usageType, createdAt])
}
